/*
 * Pulp 3 API
 *
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * API version: v3
 * Contact: pulp-list@redhat.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ContentPackageIndicesApiService ContentPackageIndicesApi service
type ContentPackageIndicesApiService service

type ApiContentDebPackageIndicesCreateRequest struct {
	ctx _context.Context
	ApiService *ContentPackageIndicesApiService
	debPackageIndex *DebPackageIndex
}

func (r ApiContentDebPackageIndicesCreateRequest) DebPackageIndex(debPackageIndex DebPackageIndex) ApiContentDebPackageIndicesCreateRequest {
	r.debPackageIndex = &debPackageIndex
	return r
}

func (r ApiContentDebPackageIndicesCreateRequest) Execute() (DebPackageIndexResponse, *_nethttp.Response, error) {
	return r.ApiService.ContentDebPackageIndicesCreateExecute(r)
}

/*
 * ContentDebPackageIndicesCreate Create a package index
 * A PackageIndex represents the package indices of a single component-architecture combination.

Associated artifacts: Exactly one 'Packages' file. May optionally include one or more of
'Packages.gz', 'Packages.xz', 'Release'. If included, the 'Release' file is a legacy
per-component-and-architecture Release file.

Note: The verbatim publisher will republish all associated artifacts, while the APT publisher
(both simple and structured mode) will generate any 'Packages' files it needs when creating the
publication. It does not make use of PackageIndex content.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiContentDebPackageIndicesCreateRequest
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesCreate(ctx _context.Context) ApiContentDebPackageIndicesCreateRequest {
	return ApiContentDebPackageIndicesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DebPackageIndexResponse
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesCreateExecute(r ApiContentDebPackageIndicesCreateRequest) (DebPackageIndexResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DebPackageIndexResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPackageIndicesApiService.ContentDebPackageIndicesCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/content/deb/package_indices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.debPackageIndex == nil {
		return localVarReturnValue, nil, reportError("debPackageIndex is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.debPackageIndex
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContentDebPackageIndicesListRequest struct {
	ctx _context.Context
	ApiService *ContentPackageIndicesApiService
	architecture *string
	component *string
	limit *int32
	offset *int32
	ordering *[]string
	relativePath *string
	repositoryVersion *string
	repositoryVersionAdded *string
	repositoryVersionRemoved *string
	sha256 *string
	fields *string
	excludeFields *string
}

func (r ApiContentDebPackageIndicesListRequest) Architecture(architecture string) ApiContentDebPackageIndicesListRequest {
	r.architecture = &architecture
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Component(component string) ApiContentDebPackageIndicesListRequest {
	r.component = &component
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Limit(limit int32) ApiContentDebPackageIndicesListRequest {
	r.limit = &limit
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Offset(offset int32) ApiContentDebPackageIndicesListRequest {
	r.offset = &offset
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Ordering(ordering []string) ApiContentDebPackageIndicesListRequest {
	r.ordering = &ordering
	return r
}
func (r ApiContentDebPackageIndicesListRequest) RelativePath(relativePath string) ApiContentDebPackageIndicesListRequest {
	r.relativePath = &relativePath
	return r
}
func (r ApiContentDebPackageIndicesListRequest) RepositoryVersion(repositoryVersion string) ApiContentDebPackageIndicesListRequest {
	r.repositoryVersion = &repositoryVersion
	return r
}
func (r ApiContentDebPackageIndicesListRequest) RepositoryVersionAdded(repositoryVersionAdded string) ApiContentDebPackageIndicesListRequest {
	r.repositoryVersionAdded = &repositoryVersionAdded
	return r
}
func (r ApiContentDebPackageIndicesListRequest) RepositoryVersionRemoved(repositoryVersionRemoved string) ApiContentDebPackageIndicesListRequest {
	r.repositoryVersionRemoved = &repositoryVersionRemoved
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Sha256(sha256 string) ApiContentDebPackageIndicesListRequest {
	r.sha256 = &sha256
	return r
}
func (r ApiContentDebPackageIndicesListRequest) Fields(fields string) ApiContentDebPackageIndicesListRequest {
	r.fields = &fields
	return r
}
func (r ApiContentDebPackageIndicesListRequest) ExcludeFields(excludeFields string) ApiContentDebPackageIndicesListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiContentDebPackageIndicesListRequest) Execute() (PaginateddebPackageIndexResponseList, *_nethttp.Response, error) {
	return r.ApiService.ContentDebPackageIndicesListExecute(r)
}

/*
 * ContentDebPackageIndicesList List PackageIndices
 * A PackageIndex represents the package indices of a single component-architecture combination.

Associated artifacts: Exactly one 'Packages' file. May optionally include one or more of
'Packages.gz', 'Packages.xz', 'Release'. If included, the 'Release' file is a legacy
per-component-and-architecture Release file.

Note: The verbatim publisher will republish all associated artifacts, while the APT publisher
(both simple and structured mode) will generate any 'Packages' files it needs when creating the
publication. It does not make use of PackageIndex content.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiContentDebPackageIndicesListRequest
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesList(ctx _context.Context) ApiContentDebPackageIndicesListRequest {
	return ApiContentDebPackageIndicesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PaginateddebPackageIndexResponseList
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesListExecute(r ApiContentDebPackageIndicesListRequest) (PaginateddebPackageIndexResponseList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginateddebPackageIndexResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPackageIndicesApiService.ContentDebPackageIndicesList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/content/deb/package_indices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.architecture != nil {
		localVarQueryParams.Add("architecture", parameterToString(*r.architecture, ""))
	}
	if r.component != nil {
		localVarQueryParams.Add("component", parameterToString(*r.component, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.relativePath != nil {
		localVarQueryParams.Add("relative_path", parameterToString(*r.relativePath, ""))
	}
	if r.repositoryVersion != nil {
		localVarQueryParams.Add("repository_version", parameterToString(*r.repositoryVersion, ""))
	}
	if r.repositoryVersionAdded != nil {
		localVarQueryParams.Add("repository_version_added", parameterToString(*r.repositoryVersionAdded, ""))
	}
	if r.repositoryVersionRemoved != nil {
		localVarQueryParams.Add("repository_version_removed", parameterToString(*r.repositoryVersionRemoved, ""))
	}
	if r.sha256 != nil {
		localVarQueryParams.Add("sha256", parameterToString(*r.sha256, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiContentDebPackageIndicesReadRequest struct {
	ctx _context.Context
	ApiService *ContentPackageIndicesApiService
	pulpId string
	fields *string
	excludeFields *string
}

func (r ApiContentDebPackageIndicesReadRequest) Fields(fields string) ApiContentDebPackageIndicesReadRequest {
	r.fields = &fields
	return r
}
func (r ApiContentDebPackageIndicesReadRequest) ExcludeFields(excludeFields string) ApiContentDebPackageIndicesReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiContentDebPackageIndicesReadRequest) Execute() (DebPackageIndexResponse, *_nethttp.Response, error) {
	return r.ApiService.ContentDebPackageIndicesReadExecute(r)
}

/*
 * ContentDebPackageIndicesRead Inspect a package index
 * A PackageIndex represents the package indices of a single component-architecture combination.

Associated artifacts: Exactly one 'Packages' file. May optionally include one or more of
'Packages.gz', 'Packages.xz', 'Release'. If included, the 'Release' file is a legacy
per-component-and-architecture Release file.

Note: The verbatim publisher will republish all associated artifacts, while the APT publisher
(both simple and structured mode) will generate any 'Packages' files it needs when creating the
publication. It does not make use of PackageIndex content.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this package index.
 * @return ApiContentDebPackageIndicesReadRequest
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesRead(ctx _context.Context, pulpId string) ApiContentDebPackageIndicesReadRequest {
	return ApiContentDebPackageIndicesReadRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return DebPackageIndexResponse
 */
func (a *ContentPackageIndicesApiService) ContentDebPackageIndicesReadExecute(r ApiContentDebPackageIndicesReadRequest) (DebPackageIndexResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DebPackageIndexResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentPackageIndicesApiService.ContentDebPackageIndicesRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/content/deb/package_indices/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
