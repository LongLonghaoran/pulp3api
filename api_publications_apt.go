/*
 * Pulp 3 API
 *
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * API version: v3
 * Contact: pulp-list@redhat.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// PublicationsAptApiService PublicationsAptApi service
type PublicationsAptApiService service

type ApiPublicationsDebAptCreateRequest struct {
	ctx _context.Context
	ApiService *PublicationsAptApiService
	debAptPublication *DebAptPublication
}

func (r ApiPublicationsDebAptCreateRequest) DebAptPublication(debAptPublication DebAptPublication) ApiPublicationsDebAptCreateRequest {
	r.debAptPublication = &debAptPublication
	return r
}

func (r ApiPublicationsDebAptCreateRequest) Execute() (AsyncOperationResponse, *_nethttp.Response, error) {
	return r.ApiService.PublicationsDebAptCreateExecute(r)
}

/*
 * PublicationsDebAptCreate Create an apt publication
 * Trigger an asynchronous task to publish content
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPublicationsDebAptCreateRequest
 */
func (a *PublicationsAptApiService) PublicationsDebAptCreate(ctx _context.Context) ApiPublicationsDebAptCreateRequest {
	return ApiPublicationsDebAptCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AsyncOperationResponse
 */
func (a *PublicationsAptApiService) PublicationsDebAptCreateExecute(r ApiPublicationsDebAptCreateRequest) (AsyncOperationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.debAptPublication == nil {
		return localVarReturnValue, nil, reportError("debAptPublication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.debAptPublication
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicationsDebAptDeleteRequest struct {
	ctx _context.Context
	ApiService *PublicationsAptApiService
	pulpId string
}


func (r ApiPublicationsDebAptDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicationsDebAptDeleteExecute(r)
}

/*
 * PublicationsDebAptDelete Delete an apt publication
 * An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt publication.
 * @return ApiPublicationsDebAptDeleteRequest
 */
func (a *PublicationsAptApiService) PublicationsDebAptDelete(ctx _context.Context, pulpId string) ApiPublicationsDebAptDeleteRequest {
	return ApiPublicationsDebAptDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 */
func (a *PublicationsAptApiService) PublicationsDebAptDeleteExecute(r ApiPublicationsDebAptDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicationsDebAptListRequest struct {
	ctx _context.Context
	ApiService *PublicationsAptApiService
	content *string
	contentIn *string
	limit *int32
	offset *int32
	ordering *[]string
	pulpCreated *time.Time
	pulpCreatedGt *time.Time
	pulpCreatedGte *time.Time
	pulpCreatedLt *time.Time
	pulpCreatedLte *time.Time
	pulpCreatedRange *[]time.Time
	repository *string
	repositoryVersion *string
	fields *string
	excludeFields *string
}

func (r ApiPublicationsDebAptListRequest) Content(content string) ApiPublicationsDebAptListRequest {
	r.content = &content
	return r
}
func (r ApiPublicationsDebAptListRequest) ContentIn(contentIn string) ApiPublicationsDebAptListRequest {
	r.contentIn = &contentIn
	return r
}
func (r ApiPublicationsDebAptListRequest) Limit(limit int32) ApiPublicationsDebAptListRequest {
	r.limit = &limit
	return r
}
func (r ApiPublicationsDebAptListRequest) Offset(offset int32) ApiPublicationsDebAptListRequest {
	r.offset = &offset
	return r
}
func (r ApiPublicationsDebAptListRequest) Ordering(ordering []string) ApiPublicationsDebAptListRequest {
	r.ordering = &ordering
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreated(pulpCreated time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreated = &pulpCreated
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreatedGt(pulpCreatedGt time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedGt = &pulpCreatedGt
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreatedGte(pulpCreatedGte time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedGte = &pulpCreatedGte
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreatedLt(pulpCreatedLt time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedLt = &pulpCreatedLt
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreatedLte(pulpCreatedLte time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedLte = &pulpCreatedLte
	return r
}
func (r ApiPublicationsDebAptListRequest) PulpCreatedRange(pulpCreatedRange []time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedRange = &pulpCreatedRange
	return r
}
func (r ApiPublicationsDebAptListRequest) Repository(repository string) ApiPublicationsDebAptListRequest {
	r.repository = &repository
	return r
}
func (r ApiPublicationsDebAptListRequest) RepositoryVersion(repositoryVersion string) ApiPublicationsDebAptListRequest {
	r.repositoryVersion = &repositoryVersion
	return r
}
func (r ApiPublicationsDebAptListRequest) Fields(fields string) ApiPublicationsDebAptListRequest {
	r.fields = &fields
	return r
}
func (r ApiPublicationsDebAptListRequest) ExcludeFields(excludeFields string) ApiPublicationsDebAptListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiPublicationsDebAptListRequest) Execute() (PaginateddebAptPublicationResponseList, *_nethttp.Response, error) {
	return r.ApiService.PublicationsDebAptListExecute(r)
}

/*
 * PublicationsDebAptList List apt publications
 * An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPublicationsDebAptListRequest
 */
func (a *PublicationsAptApiService) PublicationsDebAptList(ctx _context.Context) ApiPublicationsDebAptListRequest {
	return ApiPublicationsDebAptListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PaginateddebAptPublicationResponseList
 */
func (a *PublicationsAptApiService) PublicationsDebAptListExecute(r ApiPublicationsDebAptListRequest) (PaginateddebAptPublicationResponseList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginateddebAptPublicationResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.contentIn != nil {
		localVarQueryParams.Add("content__in", parameterToString(*r.contentIn, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.pulpCreated != nil {
		localVarQueryParams.Add("pulp_created", parameterToString(*r.pulpCreated, ""))
	}
	if r.pulpCreatedGt != nil {
		localVarQueryParams.Add("pulp_created__gt", parameterToString(*r.pulpCreatedGt, ""))
	}
	if r.pulpCreatedGte != nil {
		localVarQueryParams.Add("pulp_created__gte", parameterToString(*r.pulpCreatedGte, ""))
	}
	if r.pulpCreatedLt != nil {
		localVarQueryParams.Add("pulp_created__lt", parameterToString(*r.pulpCreatedLt, ""))
	}
	if r.pulpCreatedLte != nil {
		localVarQueryParams.Add("pulp_created__lte", parameterToString(*r.pulpCreatedLte, ""))
	}
	if r.pulpCreatedRange != nil {
		localVarQueryParams.Add("pulp_created__range", parameterToString(*r.pulpCreatedRange, "csv"))
	}
	if r.repository != nil {
		localVarQueryParams.Add("repository", parameterToString(*r.repository, ""))
	}
	if r.repositoryVersion != nil {
		localVarQueryParams.Add("repository_version", parameterToString(*r.repositoryVersion, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicationsDebAptReadRequest struct {
	ctx _context.Context
	ApiService *PublicationsAptApiService
	pulpId string
	fields *string
	excludeFields *string
}

func (r ApiPublicationsDebAptReadRequest) Fields(fields string) ApiPublicationsDebAptReadRequest {
	r.fields = &fields
	return r
}
func (r ApiPublicationsDebAptReadRequest) ExcludeFields(excludeFields string) ApiPublicationsDebAptReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiPublicationsDebAptReadRequest) Execute() (DebAptPublicationResponse, *_nethttp.Response, error) {
	return r.ApiService.PublicationsDebAptReadExecute(r)
}

/*
 * PublicationsDebAptRead Inspect an apt publication
 * An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt publication.
 * @return ApiPublicationsDebAptReadRequest
 */
func (a *PublicationsAptApiService) PublicationsDebAptRead(ctx _context.Context, pulpId string) ApiPublicationsDebAptReadRequest {
	return ApiPublicationsDebAptReadRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return DebAptPublicationResponse
 */
func (a *PublicationsAptApiService) PublicationsDebAptReadExecute(r ApiPublicationsDebAptReadRequest) (DebAptPublicationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DebAptPublicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
