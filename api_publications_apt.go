/*
Pulp 3 API

Fetch, Upload, Organize, and Distribute Software Packages

API version: v3
Contact: pulp-list@redhat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// PublicationsAptApiService PublicationsAptApi service
type PublicationsAptApiService service

type ApiPublicationsDebAptCreateRequest struct {
	ctx context.Context
	ApiService *PublicationsAptApiService
	debAptPublication *DebAptPublication
}

func (r ApiPublicationsDebAptCreateRequest) DebAptPublication(debAptPublication DebAptPublication) ApiPublicationsDebAptCreateRequest {
	r.debAptPublication = &debAptPublication
	return r
}

func (r ApiPublicationsDebAptCreateRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.PublicationsDebAptCreateExecute(r)
}

/*
PublicationsDebAptCreate Create an apt publication

Trigger an asynchronous task to publish content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublicationsDebAptCreateRequest
*/
func (a *PublicationsAptApiService) PublicationsDebAptCreate(ctx context.Context) ApiPublicationsDebAptCreateRequest {
	return ApiPublicationsDebAptCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *PublicationsAptApiService) PublicationsDebAptCreateExecute(r ApiPublicationsDebAptCreateRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.debAptPublication == nil {
		return localVarReturnValue, nil, reportError("debAptPublication is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.debAptPublication
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicationsDebAptDeleteRequest struct {
	ctx context.Context
	ApiService *PublicationsAptApiService
	pulpId string
}

func (r ApiPublicationsDebAptDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublicationsDebAptDeleteExecute(r)
}

/*
PublicationsDebAptDelete Delete an apt publication

An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this apt publication.
 @return ApiPublicationsDebAptDeleteRequest
*/
func (a *PublicationsAptApiService) PublicationsDebAptDelete(ctx context.Context, pulpId string) ApiPublicationsDebAptDeleteRequest {
	return ApiPublicationsDebAptDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
func (a *PublicationsAptApiService) PublicationsDebAptDeleteExecute(r ApiPublicationsDebAptDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublicationsDebAptListRequest struct {
	ctx context.Context
	ApiService *PublicationsAptApiService
	content *string
	contentIn *string
	limit *int32
	offset *int32
	ordering *[]string
	pulpCreated *time.Time
	pulpCreatedGt *time.Time
	pulpCreatedGte *time.Time
	pulpCreatedLt *time.Time
	pulpCreatedLte *time.Time
	pulpCreatedRange *[]time.Time
	repository *string
	repositoryVersion *string
	fields *string
	excludeFields *string
}

// Content Unit referenced by HREF
func (r ApiPublicationsDebAptListRequest) Content(content string) ApiPublicationsDebAptListRequest {
	r.content = &content
	return r
}

// Content Unit referenced by HREF
func (r ApiPublicationsDebAptListRequest) ContentIn(contentIn string) ApiPublicationsDebAptListRequest {
	r.contentIn = &contentIn
	return r
}

// Number of results to return per page.
func (r ApiPublicationsDebAptListRequest) Limit(limit int32) ApiPublicationsDebAptListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPublicationsDebAptListRequest) Offset(offset int32) ApiPublicationsDebAptListRequest {
	r.offset = &offset
	return r
}

// Ordering
func (r ApiPublicationsDebAptListRequest) Ordering(ordering []string) ApiPublicationsDebAptListRequest {
	r.ordering = &ordering
	return r
}

// ISO 8601 formatted dates are supported
func (r ApiPublicationsDebAptListRequest) PulpCreated(pulpCreated time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreated = &pulpCreated
	return r
}

// Filter results where pulp_created is greater than value
func (r ApiPublicationsDebAptListRequest) PulpCreatedGt(pulpCreatedGt time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedGt = &pulpCreatedGt
	return r
}

// Filter results where pulp_created is greater than or equal to value
func (r ApiPublicationsDebAptListRequest) PulpCreatedGte(pulpCreatedGte time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedGte = &pulpCreatedGte
	return r
}

// Filter results where pulp_created is less than value
func (r ApiPublicationsDebAptListRequest) PulpCreatedLt(pulpCreatedLt time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedLt = &pulpCreatedLt
	return r
}

// Filter results where pulp_created is less than or equal to value
func (r ApiPublicationsDebAptListRequest) PulpCreatedLte(pulpCreatedLte time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedLte = &pulpCreatedLte
	return r
}

// Filter results where pulp_created is between two comma separated values
func (r ApiPublicationsDebAptListRequest) PulpCreatedRange(pulpCreatedRange []time.Time) ApiPublicationsDebAptListRequest {
	r.pulpCreatedRange = &pulpCreatedRange
	return r
}

// Repository referenced by HREF
func (r ApiPublicationsDebAptListRequest) Repository(repository string) ApiPublicationsDebAptListRequest {
	r.repository = &repository
	return r
}

// Repository Version referenced by HREF
func (r ApiPublicationsDebAptListRequest) RepositoryVersion(repositoryVersion string) ApiPublicationsDebAptListRequest {
	r.repositoryVersion = &repositoryVersion
	return r
}

// A list of fields to include in the response.
func (r ApiPublicationsDebAptListRequest) Fields(fields string) ApiPublicationsDebAptListRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiPublicationsDebAptListRequest) ExcludeFields(excludeFields string) ApiPublicationsDebAptListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiPublicationsDebAptListRequest) Execute() (*PaginateddebAptPublicationResponseList, *http.Response, error) {
	return r.ApiService.PublicationsDebAptListExecute(r)
}

/*
PublicationsDebAptList List apt publications

An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublicationsDebAptListRequest
*/
func (a *PublicationsAptApiService) PublicationsDebAptList(ctx context.Context) ApiPublicationsDebAptListRequest {
	return ApiPublicationsDebAptListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginateddebAptPublicationResponseList
func (a *PublicationsAptApiService) PublicationsDebAptListExecute(r ApiPublicationsDebAptListRequest) (*PaginateddebAptPublicationResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginateddebAptPublicationResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.contentIn != nil {
		localVarQueryParams.Add("content__in", parameterToString(*r.contentIn, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.pulpCreated != nil {
		localVarQueryParams.Add("pulp_created", parameterToString(*r.pulpCreated, ""))
	}
	if r.pulpCreatedGt != nil {
		localVarQueryParams.Add("pulp_created__gt", parameterToString(*r.pulpCreatedGt, ""))
	}
	if r.pulpCreatedGte != nil {
		localVarQueryParams.Add("pulp_created__gte", parameterToString(*r.pulpCreatedGte, ""))
	}
	if r.pulpCreatedLt != nil {
		localVarQueryParams.Add("pulp_created__lt", parameterToString(*r.pulpCreatedLt, ""))
	}
	if r.pulpCreatedLte != nil {
		localVarQueryParams.Add("pulp_created__lte", parameterToString(*r.pulpCreatedLte, ""))
	}
	if r.pulpCreatedRange != nil {
		localVarQueryParams.Add("pulp_created__range", parameterToString(*r.pulpCreatedRange, "csv"))
	}
	if r.repository != nil {
		localVarQueryParams.Add("repository", parameterToString(*r.repository, ""))
	}
	if r.repositoryVersion != nil {
		localVarQueryParams.Add("repository_version", parameterToString(*r.repositoryVersion, ""))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicationsDebAptReadRequest struct {
	ctx context.Context
	ApiService *PublicationsAptApiService
	pulpId string
	fields *string
	excludeFields *string
}

// A list of fields to include in the response.
func (r ApiPublicationsDebAptReadRequest) Fields(fields string) ApiPublicationsDebAptReadRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiPublicationsDebAptReadRequest) ExcludeFields(excludeFields string) ApiPublicationsDebAptReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiPublicationsDebAptReadRequest) Execute() (*DebAptPublicationResponse, *http.Response, error) {
	return r.ApiService.PublicationsDebAptReadExecute(r)
}

/*
PublicationsDebAptRead Inspect an apt publication

An AptPublication is the ready to serve Pulp-internal representation of an AptRepositoryVersion.

When creating an APT publication, users must use simple or structured mode (or both). If the
publication should include '.deb' packages that were manually uploaded to the relevant
AptRepository, users must use 'simple=true'. Conversely, 'structured=true' is only useful for
publishing content obtained via synchronization. Once a Pulp publication has been created, it
can be served by creating a Pulp distribution (in a near atomic action).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this apt publication.
 @return ApiPublicationsDebAptReadRequest
*/
func (a *PublicationsAptApiService) PublicationsDebAptRead(ctx context.Context, pulpId string) ApiPublicationsDebAptReadRequest {
	return ApiPublicationsDebAptReadRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return DebAptPublicationResponse
func (a *PublicationsAptApiService) PublicationsDebAptReadExecute(r ApiPublicationsDebAptReadRequest) (*DebAptPublicationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DebAptPublicationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicationsAptApiService.PublicationsDebAptRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/publications/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
