/*
 * Pulp 3 API
 *
 * Fetch, Upload, Organize, and Distribute Software Packages
 *
 * API version: v3
 * Contact: pulp-list@redhat.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// RemotesAptApiService RemotesAptApi service
type RemotesAptApiService service

type ApiRemotesDebAptCreateRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	debAptRemote *DebAptRemote
}

func (r ApiRemotesDebAptCreateRequest) DebAptRemote(debAptRemote DebAptRemote) ApiRemotesDebAptCreateRequest {
	r.debAptRemote = &debAptRemote
	return r
}

func (r ApiRemotesDebAptCreateRequest) Execute() (DebAptRemoteResponse, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptCreateExecute(r)
}

/*
 * RemotesDebAptCreate Create an apt remote
 * An AptRemote represents an external APT repository content source.

It contains the location of the upstream APT repository, as well as the user options that are
applied when using the remote to synchronize the upstream repository to Pulp.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRemotesDebAptCreateRequest
 */
func (a *RemotesAptApiService) RemotesDebAptCreate(ctx _context.Context) ApiRemotesDebAptCreateRequest {
	return ApiRemotesDebAptCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DebAptRemoteResponse
 */
func (a *RemotesAptApiService) RemotesDebAptCreateExecute(r ApiRemotesDebAptCreateRequest) (DebAptRemoteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DebAptRemoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.debAptRemote == nil {
		return localVarReturnValue, nil, reportError("debAptRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.debAptRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemotesDebAptDeleteRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	pulpId string
}


func (r ApiRemotesDebAptDeleteRequest) Execute() (AsyncOperationResponse, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptDeleteExecute(r)
}

/*
 * RemotesDebAptDelete Delete an apt remote
 * Trigger an asynchronous delete task
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt remote.
 * @return ApiRemotesDebAptDeleteRequest
 */
func (a *RemotesAptApiService) RemotesDebAptDelete(ctx _context.Context, pulpId string) ApiRemotesDebAptDeleteRequest {
	return ApiRemotesDebAptDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return AsyncOperationResponse
 */
func (a *RemotesAptApiService) RemotesDebAptDeleteExecute(r ApiRemotesDebAptDeleteRequest) (AsyncOperationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemotesDebAptListRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	limit *int32
	name *string
	nameContains *string
	nameIcontains *string
	nameIn *[]string
	nameStartswith *string
	offset *int32
	ordering *[]string
	pulpLabelSelect *string
	pulpLastUpdated *time.Time
	pulpLastUpdatedGt *time.Time
	pulpLastUpdatedGte *time.Time
	pulpLastUpdatedLt *time.Time
	pulpLastUpdatedLte *time.Time
	pulpLastUpdatedRange *[]time.Time
	fields *string
	excludeFields *string
}

func (r ApiRemotesDebAptListRequest) Limit(limit int32) ApiRemotesDebAptListRequest {
	r.limit = &limit
	return r
}
func (r ApiRemotesDebAptListRequest) Name(name string) ApiRemotesDebAptListRequest {
	r.name = &name
	return r
}
func (r ApiRemotesDebAptListRequest) NameContains(nameContains string) ApiRemotesDebAptListRequest {
	r.nameContains = &nameContains
	return r
}
func (r ApiRemotesDebAptListRequest) NameIcontains(nameIcontains string) ApiRemotesDebAptListRequest {
	r.nameIcontains = &nameIcontains
	return r
}
func (r ApiRemotesDebAptListRequest) NameIn(nameIn []string) ApiRemotesDebAptListRequest {
	r.nameIn = &nameIn
	return r
}
func (r ApiRemotesDebAptListRequest) NameStartswith(nameStartswith string) ApiRemotesDebAptListRequest {
	r.nameStartswith = &nameStartswith
	return r
}
func (r ApiRemotesDebAptListRequest) Offset(offset int32) ApiRemotesDebAptListRequest {
	r.offset = &offset
	return r
}
func (r ApiRemotesDebAptListRequest) Ordering(ordering []string) ApiRemotesDebAptListRequest {
	r.ordering = &ordering
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLabelSelect(pulpLabelSelect string) ApiRemotesDebAptListRequest {
	r.pulpLabelSelect = &pulpLabelSelect
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdated(pulpLastUpdated time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdated = &pulpLastUpdated
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdatedGt(pulpLastUpdatedGt time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdatedGt = &pulpLastUpdatedGt
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdatedGte(pulpLastUpdatedGte time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdatedGte = &pulpLastUpdatedGte
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdatedLt(pulpLastUpdatedLt time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdatedLt = &pulpLastUpdatedLt
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdatedLte(pulpLastUpdatedLte time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdatedLte = &pulpLastUpdatedLte
	return r
}
func (r ApiRemotesDebAptListRequest) PulpLastUpdatedRange(pulpLastUpdatedRange []time.Time) ApiRemotesDebAptListRequest {
	r.pulpLastUpdatedRange = &pulpLastUpdatedRange
	return r
}
func (r ApiRemotesDebAptListRequest) Fields(fields string) ApiRemotesDebAptListRequest {
	r.fields = &fields
	return r
}
func (r ApiRemotesDebAptListRequest) ExcludeFields(excludeFields string) ApiRemotesDebAptListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiRemotesDebAptListRequest) Execute() (PaginateddebAptRemoteResponseList, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptListExecute(r)
}

/*
 * RemotesDebAptList List apt remotes
 * An AptRemote represents an external APT repository content source.

It contains the location of the upstream APT repository, as well as the user options that are
applied when using the remote to synchronize the upstream repository to Pulp.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRemotesDebAptListRequest
 */
func (a *RemotesAptApiService) RemotesDebAptList(ctx _context.Context) ApiRemotesDebAptListRequest {
	return ApiRemotesDebAptListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PaginateddebAptRemoteResponseList
 */
func (a *RemotesAptApiService) RemotesDebAptListExecute(r ApiRemotesDebAptListRequest) (PaginateddebAptRemoteResponseList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginateddebAptRemoteResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameContains != nil {
		localVarQueryParams.Add("name__contains", parameterToString(*r.nameContains, ""))
	}
	if r.nameIcontains != nil {
		localVarQueryParams.Add("name__icontains", parameterToString(*r.nameIcontains, ""))
	}
	if r.nameIn != nil {
		localVarQueryParams.Add("name__in", parameterToString(*r.nameIn, "csv"))
	}
	if r.nameStartswith != nil {
		localVarQueryParams.Add("name__startswith", parameterToString(*r.nameStartswith, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.pulpLabelSelect != nil {
		localVarQueryParams.Add("pulp_label_select", parameterToString(*r.pulpLabelSelect, ""))
	}
	if r.pulpLastUpdated != nil {
		localVarQueryParams.Add("pulp_last_updated", parameterToString(*r.pulpLastUpdated, ""))
	}
	if r.pulpLastUpdatedGt != nil {
		localVarQueryParams.Add("pulp_last_updated__gt", parameterToString(*r.pulpLastUpdatedGt, ""))
	}
	if r.pulpLastUpdatedGte != nil {
		localVarQueryParams.Add("pulp_last_updated__gte", parameterToString(*r.pulpLastUpdatedGte, ""))
	}
	if r.pulpLastUpdatedLt != nil {
		localVarQueryParams.Add("pulp_last_updated__lt", parameterToString(*r.pulpLastUpdatedLt, ""))
	}
	if r.pulpLastUpdatedLte != nil {
		localVarQueryParams.Add("pulp_last_updated__lte", parameterToString(*r.pulpLastUpdatedLte, ""))
	}
	if r.pulpLastUpdatedRange != nil {
		localVarQueryParams.Add("pulp_last_updated__range", parameterToString(*r.pulpLastUpdatedRange, "csv"))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemotesDebAptPartialUpdateRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	pulpId string
	patcheddebAptRemote *PatcheddebAptRemote
}

func (r ApiRemotesDebAptPartialUpdateRequest) PatcheddebAptRemote(patcheddebAptRemote PatcheddebAptRemote) ApiRemotesDebAptPartialUpdateRequest {
	r.patcheddebAptRemote = &patcheddebAptRemote
	return r
}

func (r ApiRemotesDebAptPartialUpdateRequest) Execute() (AsyncOperationResponse, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptPartialUpdateExecute(r)
}

/*
 * RemotesDebAptPartialUpdate Update an apt remote
 * Trigger an asynchronous partial update task
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt remote.
 * @return ApiRemotesDebAptPartialUpdateRequest
 */
func (a *RemotesAptApiService) RemotesDebAptPartialUpdate(ctx _context.Context, pulpId string) ApiRemotesDebAptPartialUpdateRequest {
	return ApiRemotesDebAptPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return AsyncOperationResponse
 */
func (a *RemotesAptApiService) RemotesDebAptPartialUpdateExecute(r ApiRemotesDebAptPartialUpdateRequest) (AsyncOperationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.patcheddebAptRemote == nil {
		return localVarReturnValue, nil, reportError("patcheddebAptRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patcheddebAptRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemotesDebAptReadRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	pulpId string
	fields *string
	excludeFields *string
}

func (r ApiRemotesDebAptReadRequest) Fields(fields string) ApiRemotesDebAptReadRequest {
	r.fields = &fields
	return r
}
func (r ApiRemotesDebAptReadRequest) ExcludeFields(excludeFields string) ApiRemotesDebAptReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiRemotesDebAptReadRequest) Execute() (DebAptRemoteResponse, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptReadExecute(r)
}

/*
 * RemotesDebAptRead Inspect an apt remote
 * An AptRemote represents an external APT repository content source.

It contains the location of the upstream APT repository, as well as the user options that are
applied when using the remote to synchronize the upstream repository to Pulp.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt remote.
 * @return ApiRemotesDebAptReadRequest
 */
func (a *RemotesAptApiService) RemotesDebAptRead(ctx _context.Context, pulpId string) ApiRemotesDebAptReadRequest {
	return ApiRemotesDebAptReadRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return DebAptRemoteResponse
 */
func (a *RemotesAptApiService) RemotesDebAptReadExecute(r ApiRemotesDebAptReadRequest) (DebAptRemoteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DebAptRemoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemotesDebAptUpdateRequest struct {
	ctx _context.Context
	ApiService *RemotesAptApiService
	pulpId string
	debAptRemote *DebAptRemote
}

func (r ApiRemotesDebAptUpdateRequest) DebAptRemote(debAptRemote DebAptRemote) ApiRemotesDebAptUpdateRequest {
	r.debAptRemote = &debAptRemote
	return r
}

func (r ApiRemotesDebAptUpdateRequest) Execute() (AsyncOperationResponse, *_nethttp.Response, error) {
	return r.ApiService.RemotesDebAptUpdateExecute(r)
}

/*
 * RemotesDebAptUpdate Update an apt remote
 * Trigger an asynchronous update task
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param pulpId A UUID string identifying this apt remote.
 * @return ApiRemotesDebAptUpdateRequest
 */
func (a *RemotesAptApiService) RemotesDebAptUpdate(ctx _context.Context, pulpId string) ApiRemotesDebAptUpdateRequest {
	return ApiRemotesDebAptUpdateRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

/*
 * Execute executes the request
 * @return AsyncOperationResponse
 */
func (a *RemotesAptApiService) RemotesDebAptUpdateExecute(r ApiRemotesDebAptUpdateRequest) (AsyncOperationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemotesAptApiService.RemotesDebAptUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/remotes/deb/apt/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", _neturl.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.debAptRemote == nil {
		return localVarReturnValue, nil, reportError("debAptRemote is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.debAptRemote
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
