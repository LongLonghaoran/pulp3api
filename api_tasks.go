/*
Pulp 3 API

Fetch, Upload, Organize, and Distribute Software Packages

API version: v3
Contact: pulp-list@redhat.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// TasksApiService TasksApi service
type TasksApiService service

type ApiTasksAddRoleRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	nestedRole *NestedRole
}

func (r ApiTasksAddRoleRequest) NestedRole(nestedRole NestedRole) ApiTasksAddRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r ApiTasksAddRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.TasksAddRoleExecute(r)
}

/*
TasksAddRole Method for TasksAddRole

Add a role for this object to users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksAddRoleRequest
*/
func (a *TasksApiService) TasksAddRole(ctx context.Context, pulpId string) ApiTasksAddRoleRequest {
	return ApiTasksAddRoleRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *TasksApiService) TasksAddRoleExecute(r ApiTasksAddRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksAddRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/add_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksCancelRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	patchedTaskCancel *PatchedTaskCancel
}

func (r ApiTasksCancelRequest) PatchedTaskCancel(patchedTaskCancel PatchedTaskCancel) ApiTasksCancelRequest {
	r.patchedTaskCancel = &patchedTaskCancel
	return r
}

func (r ApiTasksCancelRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.TasksCancelExecute(r)
}

/*
TasksCancel Cancel a task

This operation cancels a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksCancelRequest
*/
func (a *TasksApiService) TasksCancel(ctx context.Context, pulpId string) ApiTasksCancelRequest {
	return ApiTasksCancelRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *TasksApiService) TasksCancelExecute(r ApiTasksCancelRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchedTaskCancel == nil {
		return localVarReturnValue, nil, reportError("patchedTaskCancel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTaskCancel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksDeleteRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
}

func (r ApiTasksDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.TasksDeleteExecute(r)
}

/*
TasksDelete Delete a task

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksDeleteRequest
*/
func (a *TasksApiService) TasksDelete(ctx context.Context, pulpId string) ApiTasksDeleteRequest {
	return ApiTasksDeleteRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
func (a *TasksApiService) TasksDeleteExecute(r ApiTasksDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTasksListRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	childTasks *string
	createdResources *string
	finishedAt *time.Time
	finishedAtGt *time.Time
	finishedAtGte *time.Time
	finishedAtLt *time.Time
	finishedAtLte *time.Time
	finishedAtRange *[]time.Time
	limit *int32
	loggingCid *string
	loggingCidContains *string
	name *string
	nameContains *string
	offset *int32
	ordering *[]string
	parentTask *string
	reservedResourcesRecord *[]string
	startedAt *time.Time
	startedAtGt *time.Time
	startedAtGte *time.Time
	startedAtLt *time.Time
	startedAtLte *time.Time
	startedAtRange *[]time.Time
	state *string
	stateIn *[]string
	taskGroup *string
	worker *string
	workerIn *[]string
	fields *string
	excludeFields *string
}

// Foreign Key referenced by HREF
func (r ApiTasksListRequest) ChildTasks(childTasks string) ApiTasksListRequest {
	r.childTasks = &childTasks
	return r
}

func (r ApiTasksListRequest) CreatedResources(createdResources string) ApiTasksListRequest {
	r.createdResources = &createdResources
	return r
}

// ISO 8601 formatted dates are supported
func (r ApiTasksListRequest) FinishedAt(finishedAt time.Time) ApiTasksListRequest {
	r.finishedAt = &finishedAt
	return r
}

// Filter results where finished_at is greater than value
func (r ApiTasksListRequest) FinishedAtGt(finishedAtGt time.Time) ApiTasksListRequest {
	r.finishedAtGt = &finishedAtGt
	return r
}

// Filter results where finished_at is greater than or equal to value
func (r ApiTasksListRequest) FinishedAtGte(finishedAtGte time.Time) ApiTasksListRequest {
	r.finishedAtGte = &finishedAtGte
	return r
}

// Filter results where finished_at is less than value
func (r ApiTasksListRequest) FinishedAtLt(finishedAtLt time.Time) ApiTasksListRequest {
	r.finishedAtLt = &finishedAtLt
	return r
}

// Filter results where finished_at is less than or equal to value
func (r ApiTasksListRequest) FinishedAtLte(finishedAtLte time.Time) ApiTasksListRequest {
	r.finishedAtLte = &finishedAtLte
	return r
}

// Filter results where finished_at is between two comma separated values
func (r ApiTasksListRequest) FinishedAtRange(finishedAtRange []time.Time) ApiTasksListRequest {
	r.finishedAtRange = &finishedAtRange
	return r
}

// Number of results to return per page.
func (r ApiTasksListRequest) Limit(limit int32) ApiTasksListRequest {
	r.limit = &limit
	return r
}

func (r ApiTasksListRequest) LoggingCid(loggingCid string) ApiTasksListRequest {
	r.loggingCid = &loggingCid
	return r
}

// Filter results where logging_cid contains value
func (r ApiTasksListRequest) LoggingCidContains(loggingCidContains string) ApiTasksListRequest {
	r.loggingCidContains = &loggingCidContains
	return r
}

func (r ApiTasksListRequest) Name(name string) ApiTasksListRequest {
	r.name = &name
	return r
}

// Filter results where name contains value
func (r ApiTasksListRequest) NameContains(nameContains string) ApiTasksListRequest {
	r.nameContains = &nameContains
	return r
}

// The initial index from which to return the results.
func (r ApiTasksListRequest) Offset(offset int32) ApiTasksListRequest {
	r.offset = &offset
	return r
}

// Ordering
func (r ApiTasksListRequest) Ordering(ordering []string) ApiTasksListRequest {
	r.ordering = &ordering
	return r
}

// Foreign Key referenced by HREF
func (r ApiTasksListRequest) ParentTask(parentTask string) ApiTasksListRequest {
	r.parentTask = &parentTask
	return r
}

func (r ApiTasksListRequest) ReservedResourcesRecord(reservedResourcesRecord []string) ApiTasksListRequest {
	r.reservedResourcesRecord = &reservedResourcesRecord
	return r
}

// ISO 8601 formatted dates are supported
func (r ApiTasksListRequest) StartedAt(startedAt time.Time) ApiTasksListRequest {
	r.startedAt = &startedAt
	return r
}

// Filter results where started_at is greater than value
func (r ApiTasksListRequest) StartedAtGt(startedAtGt time.Time) ApiTasksListRequest {
	r.startedAtGt = &startedAtGt
	return r
}

// Filter results where started_at is greater than or equal to value
func (r ApiTasksListRequest) StartedAtGte(startedAtGte time.Time) ApiTasksListRequest {
	r.startedAtGte = &startedAtGte
	return r
}

// Filter results where started_at is less than value
func (r ApiTasksListRequest) StartedAtLt(startedAtLt time.Time) ApiTasksListRequest {
	r.startedAtLt = &startedAtLt
	return r
}

// Filter results where started_at is less than or equal to value
func (r ApiTasksListRequest) StartedAtLte(startedAtLte time.Time) ApiTasksListRequest {
	r.startedAtLte = &startedAtLte
	return r
}

// Filter results where started_at is between two comma separated values
func (r ApiTasksListRequest) StartedAtRange(startedAtRange []time.Time) ApiTasksListRequest {
	r.startedAtRange = &startedAtRange
	return r
}

func (r ApiTasksListRequest) State(state string) ApiTasksListRequest {
	r.state = &state
	return r
}

// Filter results where state is in a comma-separated list of values
func (r ApiTasksListRequest) StateIn(stateIn []string) ApiTasksListRequest {
	r.stateIn = &stateIn
	return r
}

// Foreign Key referenced by HREF
func (r ApiTasksListRequest) TaskGroup(taskGroup string) ApiTasksListRequest {
	r.taskGroup = &taskGroup
	return r
}

// Foreign Key referenced by HREF
func (r ApiTasksListRequest) Worker(worker string) ApiTasksListRequest {
	r.worker = &worker
	return r
}

// Filter results where worker is in a comma-separated list of values
func (r ApiTasksListRequest) WorkerIn(workerIn []string) ApiTasksListRequest {
	r.workerIn = &workerIn
	return r
}

// A list of fields to include in the response.
func (r ApiTasksListRequest) Fields(fields string) ApiTasksListRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiTasksListRequest) ExcludeFields(excludeFields string) ApiTasksListRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiTasksListRequest) Execute() (*PaginatedTaskResponseList, *http.Response, error) {
	return r.ApiService.TasksListExecute(r)
}

/*
TasksList List tasks

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTasksListRequest
*/
func (a *TasksApiService) TasksList(ctx context.Context) ApiTasksListRequest {
	return ApiTasksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTaskResponseList
func (a *TasksApiService) TasksListExecute(r ApiTasksListRequest) (*PaginatedTaskResponseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTaskResponseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.childTasks != nil {
		localVarQueryParams.Add("child_tasks", parameterToString(*r.childTasks, ""))
	}
	if r.createdResources != nil {
		localVarQueryParams.Add("created_resources", parameterToString(*r.createdResources, ""))
	}
	if r.finishedAt != nil {
		localVarQueryParams.Add("finished_at", parameterToString(*r.finishedAt, ""))
	}
	if r.finishedAtGt != nil {
		localVarQueryParams.Add("finished_at__gt", parameterToString(*r.finishedAtGt, ""))
	}
	if r.finishedAtGte != nil {
		localVarQueryParams.Add("finished_at__gte", parameterToString(*r.finishedAtGte, ""))
	}
	if r.finishedAtLt != nil {
		localVarQueryParams.Add("finished_at__lt", parameterToString(*r.finishedAtLt, ""))
	}
	if r.finishedAtLte != nil {
		localVarQueryParams.Add("finished_at__lte", parameterToString(*r.finishedAtLte, ""))
	}
	if r.finishedAtRange != nil {
		localVarQueryParams.Add("finished_at__range", parameterToString(*r.finishedAtRange, "csv"))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.loggingCid != nil {
		localVarQueryParams.Add("logging_cid", parameterToString(*r.loggingCid, ""))
	}
	if r.loggingCidContains != nil {
		localVarQueryParams.Add("logging_cid__contains", parameterToString(*r.loggingCidContains, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.nameContains != nil {
		localVarQueryParams.Add("name__contains", parameterToString(*r.nameContains, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.ordering != nil {
		localVarQueryParams.Add("ordering", parameterToString(*r.ordering, "csv"))
	}
	if r.parentTask != nil {
		localVarQueryParams.Add("parent_task", parameterToString(*r.parentTask, ""))
	}
	if r.reservedResourcesRecord != nil {
		t := *r.reservedResourcesRecord
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("reserved_resources_record", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("reserved_resources_record", parameterToString(t, "multi"))
		}
	}
	if r.startedAt != nil {
		localVarQueryParams.Add("started_at", parameterToString(*r.startedAt, ""))
	}
	if r.startedAtGt != nil {
		localVarQueryParams.Add("started_at__gt", parameterToString(*r.startedAtGt, ""))
	}
	if r.startedAtGte != nil {
		localVarQueryParams.Add("started_at__gte", parameterToString(*r.startedAtGte, ""))
	}
	if r.startedAtLt != nil {
		localVarQueryParams.Add("started_at__lt", parameterToString(*r.startedAtLt, ""))
	}
	if r.startedAtLte != nil {
		localVarQueryParams.Add("started_at__lte", parameterToString(*r.startedAtLte, ""))
	}
	if r.startedAtRange != nil {
		localVarQueryParams.Add("started_at__range", parameterToString(*r.startedAtRange, "csv"))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.stateIn != nil {
		localVarQueryParams.Add("state__in", parameterToString(*r.stateIn, "csv"))
	}
	if r.taskGroup != nil {
		localVarQueryParams.Add("task_group", parameterToString(*r.taskGroup, ""))
	}
	if r.worker != nil {
		localVarQueryParams.Add("worker", parameterToString(*r.worker, ""))
	}
	if r.workerIn != nil {
		localVarQueryParams.Add("worker__in", parameterToString(*r.workerIn, "csv"))
	}
	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksListRolesRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	fields *string
	excludeFields *string
}

// A list of fields to include in the response.
func (r ApiTasksListRolesRequest) Fields(fields string) ApiTasksListRolesRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiTasksListRolesRequest) ExcludeFields(excludeFields string) ApiTasksListRolesRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiTasksListRolesRequest) Execute() (*ObjectRolesResponse, *http.Response, error) {
	return r.ApiService.TasksListRolesExecute(r)
}

/*
TasksListRoles Method for TasksListRoles

List roles assigned to this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksListRolesRequest
*/
func (a *TasksApiService) TasksListRoles(ctx context.Context, pulpId string) ApiTasksListRolesRequest {
	return ApiTasksListRolesRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return ObjectRolesResponse
func (a *TasksApiService) TasksListRolesExecute(r ApiTasksListRolesRequest) (*ObjectRolesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectRolesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksListRoles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/list_roles/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksMyPermissionsRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	fields *string
	excludeFields *string
}

// A list of fields to include in the response.
func (r ApiTasksMyPermissionsRequest) Fields(fields string) ApiTasksMyPermissionsRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiTasksMyPermissionsRequest) ExcludeFields(excludeFields string) ApiTasksMyPermissionsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiTasksMyPermissionsRequest) Execute() (*MyPermissionsResponse, *http.Response, error) {
	return r.ApiService.TasksMyPermissionsExecute(r)
}

/*
TasksMyPermissions Method for TasksMyPermissions

List permissions available to the current user on this object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksMyPermissionsRequest
*/
func (a *TasksApiService) TasksMyPermissions(ctx context.Context, pulpId string) ApiTasksMyPermissionsRequest {
	return ApiTasksMyPermissionsRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return MyPermissionsResponse
func (a *TasksApiService) TasksMyPermissionsExecute(r ApiTasksMyPermissionsRequest) (*MyPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MyPermissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksMyPermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/my_permissions/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksPurgeRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	purge *Purge
}

func (r ApiTasksPurgeRequest) Purge(purge Purge) ApiTasksPurgeRequest {
	r.purge = &purge
	return r
}

func (r ApiTasksPurgeRequest) Execute() (*AsyncOperationResponse, *http.Response, error) {
	return r.ApiService.TasksPurgeExecute(r)
}

/*
TasksPurge Purge Completed Tasks

Trigger an asynchronous task that deletes completed tasks that finished prior to a specified timestamp (tech-preview, may change in the future).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTasksPurgeRequest
*/
func (a *TasksApiService) TasksPurge(ctx context.Context) ApiTasksPurgeRequest {
	return ApiTasksPurgeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AsyncOperationResponse
func (a *TasksApiService) TasksPurgeExecute(r ApiTasksPurgeRequest) (*AsyncOperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncOperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksPurge")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/purge/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.purge == nil {
		return localVarReturnValue, nil, reportError("purge is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purge
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksReadRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	fields *string
	excludeFields *string
}

// A list of fields to include in the response.
func (r ApiTasksReadRequest) Fields(fields string) ApiTasksReadRequest {
	r.fields = &fields
	return r
}

// A list of fields to exclude from the response.
func (r ApiTasksReadRequest) ExcludeFields(excludeFields string) ApiTasksReadRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiTasksReadRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.TasksReadExecute(r)
}

/*
TasksRead Inspect a task

A customized named ModelViewSet that knows how to register itself with the Pulp API router.

This viewset is discoverable by its name.
"Normal" Django Models and Master/Detail models are supported by the ``register_with`` method.

Attributes:
    lookup_field (str): The name of the field by which an object should be looked up, in
        addition to any parent lookups if this ViewSet is nested. Defaults to 'pk'
    endpoint_name (str): The name of the final path segment that should identify the ViewSet's
        collection endpoint.
    nest_prefix (str): Optional prefix under which this ViewSet should be nested. This must
        correspond to the "parent_prefix" of a router with rest_framework_nested.NestedMixin.
        None indicates this ViewSet should not be nested.
    parent_lookup_kwargs (dict): Optional mapping of key names that would appear in self.kwargs
        to django model filter expressions that can be used with the corresponding value from
        self.kwargs, used only by a nested ViewSet to filter based on the parent object's
        identity.
    schema (DefaultSchema): The schema class to use by default in a viewset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksReadRequest
*/
func (a *TasksApiService) TasksRead(ctx context.Context, pulpId string) ApiTasksReadRequest {
	return ApiTasksReadRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *TasksApiService) TasksReadExecute(r ApiTasksReadRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		localVarQueryParams.Add("fields", parameterToString(*r.fields, ""))
	}
	if r.excludeFields != nil {
		localVarQueryParams.Add("exclude_fields", parameterToString(*r.excludeFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTasksRemoveRoleRequest struct {
	ctx context.Context
	ApiService *TasksApiService
	pulpId string
	nestedRole *NestedRole
}

func (r ApiTasksRemoveRoleRequest) NestedRole(nestedRole NestedRole) ApiTasksRemoveRoleRequest {
	r.nestedRole = &nestedRole
	return r
}

func (r ApiTasksRemoveRoleRequest) Execute() (*NestedRoleResponse, *http.Response, error) {
	return r.ApiService.TasksRemoveRoleExecute(r)
}

/*
TasksRemoveRole Method for TasksRemoveRole

Remove a role for this object from users/groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pulpId A UUID string identifying this task.
 @return ApiTasksRemoveRoleRequest
*/
func (a *TasksApiService) TasksRemoveRole(ctx context.Context, pulpId string) ApiTasksRemoveRoleRequest {
	return ApiTasksRemoveRoleRequest{
		ApiService: a,
		ctx: ctx,
		pulpId: pulpId,
	}
}

// Execute executes the request
//  @return NestedRoleResponse
func (a *TasksApiService) TasksRemoveRoleExecute(r ApiTasksRemoveRoleRequest) (*NestedRoleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NestedRoleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.TasksRemoveRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pulp/api/v3/tasks/{pulp_id}/remove_role/"
	localVarPath = strings.Replace(localVarPath, "{"+"pulp_id"+"}", url.PathEscape(parameterToString(r.pulpId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nestedRole == nil {
		return localVarReturnValue, nil, reportError("nestedRole is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nestedRole
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
